---
title: "Take-home_Ex1: Public Bus Passengers in Singapore"
author: "Widya Tantiya Yutika"
date: "29 November 2023"
date-modified: "last-modified"
format: html
execute: 
  echo: true
  eval: true
  warning: false
editor: visual
---

## Overview

The increasing digitization of urban infrastructures, including buses, taxis, mass rapid transit, public utilities and roads, has generated vast datasets capturing movement patterns over space and time. This data, facilitated by technologies such as GPS and RFID, offers valuable insights into human mobility within cities. Smart cards and GPS devices on public buses, for instance, have enabled the collection of routes and ridership data, providing a rich source for understanding urban movement.

Despite the wealth of data collected, its utilization often remains limited to basic tracking and mapping using Geographic Information System (GIS) applications. This limitation is attributed to the inadequacy of conventional GIS functions in effectively analyzing and modeling spatial and spatio-temporal data.

The objectives of this study are centered around employing Exploratory Spatial Data Analysis (ESDA) techniques, specifically Local Indicators of Spatial Association (LISA) and Emerging Hot Spot Analysis (EHSA), to unveil the spatial and spatio-temporal mobility patterns of public bus passengers in Singapore.

## Setting up

### **The Study Area and Data**

##### Aspatial Data

The Aspatial data used in this take-home exercise is extracted from [LTA DataMall](https://datamall.lta.gov.sg/content/datamall/en.html) (*Passenger Volume by Origin Destination Bus Stops*)

##### Geospatial Data

Two geospatial data sets will be used in this take-home exercise, which are:

-   *Bus Stop Location* from [LTA DataMall](https://datamall.lta.gov.sg/content/datamall/en.html), which provides information about all the bus stops currently being serviced by buses, including the bus stop code (identifier) and location coordinates.

-   *hexagon*, a [hexagon](https://desktop.arcgis.com/en/arcmap/latest/tools/spatial-statistics-toolbox/h-whyhexagons.htm) layer of 250m (this distance is the perpendicular distance between the centre of the hexagon and its edges.) should be used to replace the relative coarse and irregular Master Plan 2019 Planning Sub-zone GIS data set of URA.

### **Setting the Analytical Tools**

Before I get started, I need to ensure that **sf**, **spdep**, **tmap**, **tidyverse,** and **knitr** packages of R are currently installed in my R.

-   *sf* : for importing and handling geospatial data in R,

-   *spdep* : for computing spatial weights, global and local spatial autocorrelation statistics, and

-   *tmap* : for preparing cartographic quality chropleth map

-   *tidyverse* : for wrangling attribute data in R

-   knitr: for facilitating dynamic report generation in R Markdown documents.

The code chunk below is used to ensure that the necessary R packages have been installed in the R environment to be used.

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse, knitr)
```

## **Getting the Data into R Environment**

### **Importing Shapefile into R Environment**

The code chunk below uses [*`st_read()`*](https://r-spatial.github.io/sf/reference/st_read.html) of **sf** package to import BusStop shapefile into R. The imported shapefile will be **simple features** Object of **sf**.

```{r}
busstop <- st_read(dsn = "data/geospatial", layer = "BusStop")
```

The code chunk below uses [*`st_geometry()`*](https://www.rdocumentation.org/packages/sf/versions/1.0-14/topics/st_geometry) of **sf** package to display basic information of feature class.

```{r}
st_geometry(busstop)
```

The code chunk below uses [*`glimpse()`*](https://www.rdocumentation.org/packages/dplyr/versions/1.0.10/topics/glimpse) of **dplyr** package to display the data type of each fields.

```{r}
glimpse(busstop)
```

Next, I will plot the geospatial data using the code chunk below.

```{r}
plot(busstop)
```

From the glimpse() check above, it is shown that the BUS_STOP_N is in character type. It needs to be converted to factor type to work with categorical variables so that we can use them to georeference with bus stop location data.

```{r}
busstop$BUS_STOP_N <- as.factor(busstop$BUS_STOP_N)
```

Next, I will confirm the data type for BUS_STOP_N has changed to factor using glimpse().

```{r}
glimpse(busstop)
```

### **Importing Csv File into R Environment**

Next, I will import *origin_destination_bus_202310.csv* into R by using [*`st_read()`*](https://r-spatial.github.io/sf/reference/st_read.html) of **readr** package. The output is R dataframe class.

```{r}
odbus <- read_csv("data/aspatial/origin_destination_bus_202310.csv")
```

The code chunk below uses [*`glimpse()`*](https://www.rdocumentation.org/packages/dplyr/versions/1.0.10/topics/glimpse) of **dplyr** package to display the odbus tibble data tables.

```{r}
glimpse(odbus)
```

From the glimpse() check above, it is shown that the ORIGIN_PT_CODE and DESTINATION_PT_CODE are in character type. Both of them need to be converted to factor type to work with categorical variables so that we can use them to georeference with bus stop location data.

```{r}
odbus$ORIGIN_PT_CODE <- as.factor(odbus$ORIGIN_PT_CODE)
odbus$DESTINATION_PT_CODE <- as.factor(odbus$DESTINATION_PT_CODE) 
```

Next, I will confirm the data type for ORIGIN_PT_CODE and DESTINATION_PT_CODE have changed to factor using glimpse().

```{r}
glimpse(odbus)
```

## Data Wrangling

### Checking the Reference Coordinate System of Geospatial Data

Common issue in importing geospatial data into R is that the coordinate system of the source data was either missing (due to missing .proj for ESRI shapefile, etc.) or wrongly assigned.

The code chunk below uses [*`st_crs()`*](https://www.rdocumentation.org/packages/sf/versions/0.2-8/topics/st_crs) of **sf** package to retrieve the coordinate reference system of busstop.

```{r}
st_crs(busstop)
```

Both busstop is projected in svy21 as shown from the second line, but at the last line, it is mentioned that the EPSG is 9001. This is wrongly assigned because the correct EPSG code for svy21 is [3414](https://epsg.io/3414).

### Transforming the Projection

Next, I will transform busstop from geographic coordinate system to projected coordinated system as my analysis will measure distance or/and area.

The code chunk below uses [*`st_transform`*](https://r-spatial.github.io/sf/reference/st_transform.html) of **sp** package to convert coordinates to EPSG code of 3414.

```{r}
busstop3414 <- st_transform(busstop, 3414)
```

Next, we will check the coordinate system after transformation with the code chunk below.

```{r}
st_crs(busstop3414)
```

As noticed from the above, the Projected CRS is now SVY21 / Singapore TM and the last line has changed to EPSG 3414.

### Checking Duplicated Records

The code chunk below is used to check for duplicated records on odbus.

```{r}
duplicate <- odbus %>%
  group_by_all() %>%
  filter(n()>1) %>%
  ungroup()
```

The above code chunk shows that there is no duplicate record found.

### Creating honeycomb_grid

The code chunk below uses [*`st_make_grid`*](https://r-spatial.github.io/sf/reference/st_make_grid.html) of **sf** package to create a hexagonal or honeycomb grid with a 250m (perpendicular distance between the center of hexagon and its edges). According the the R documentation, the cellsize is the distance between opposite edges, which is 2 times the perpendicular distance between the center of hexagon and its edges (500m). Next, I create a grid_id for each hexagonal grid.

```{r}
area_honeycomb_grid = st_make_grid(busstop3414, c(500, 500), what = "polygons", square = FALSE)    
# To sf and add grid ID  
honeycomb_grid_sf = st_sf(area_honeycomb_grid) %>%    
  # add grid ID      
  mutate(grid_id = 1:length(lengths(area_honeycomb_grid)))
```

### Extracting the study data

For the purpose of this exercise, I will extract the commuting flows during peak hours as follows.

|                              | Bus tap on time |
|------------------------------|-----------------|
| Weekday morning peak         | 6am to 9am      |
| Weekday afternoon peak       | 5pm to 8pm      |
| Weekend/holiday morning peak | 11am to 2pm     |
| Weekend/holiday evening peak | 4pm to 7pm      |

#### Weekday Morning Peak

The code chunk below will be used to extract the weekday morning peak (Weekday: 6-9am) and calculate the total trips in each origin and destination pair.

```{r}
odbus_weekday_6_9 <- odbus %>%
  filter(DAY_TYPE == "WEEKDAY") %>%
  filter(TIME_PER_HOUR >= 6 &
           TIME_PER_HOUR <= 9) %>%
  group_by(ORIGIN_PT_CODE,
           DESTINATION_PT_CODE) %>%
  summarise(TRIPS = sum(TOTAL_TRIPS))

```

#### Weekday Afternoon Peak

The code chunk below will be used to extract the weekday afternoon peak (Weekday: 5-8pm) and calculate the total trips in each origin and destination pair.

```{r}
odbus_weekday_17_20 <- odbus %>%   
  filter(DAY_TYPE == "WEEKDAY") %>%   
  filter(TIME_PER_HOUR >= 17 &            
           TIME_PER_HOUR <= 20) %>%   
  group_by(ORIGIN_PT_CODE,            
           DESTINATION_PT_CODE) %>%   
  summarise(TRIPS = sum(TOTAL_TRIPS)) 
```

#### Weekends/Holiday Morning Peak

The code chunk below will be used to extract the weekend/holiday morning peak (Weekend/holiday: 11am-2pm) and calculate the total trips in each origin and destination pair.

```{r}
odbus_weekend_11_14 <- odbus %>% 
  filter(DAY_TYPE == "WEEKENDS/HOLIDAY") %>%   
  filter(TIME_PER_HOUR >= 11 &            
           TIME_PER_HOUR <= 14) %>%   
  group_by(ORIGIN_PT_CODE,            
           DESTINATION_PT_CODE) %>%   
  summarise(TRIPS = sum(TOTAL_TRIPS)) 
```

#### Weekends/Holiday Evening Peak

The code chunk below will be used to extract the weekend/holiday evening peak (Weekend/holiday: 4-7pm) and calculate the total trips in each origin and destination pair.

```{r}
odbus_weekend_16_19 <- odbus %>%   
  filter(DAY_TYPE == "WEEKENDS/HOLIDAY") %>%   
  filter(TIME_PER_HOUR >= 16 &            
           TIME_PER_HOUR <= 19) %>%   
  group_by(ORIGIN_PT_CODE,            
           DESTINATION_PT_CODE) %>%   
  summarise(TRIPS = sum(TOTAL_TRIPS)) 
```

### Further Data Wrangling for Weekday Morning Peak Hour: A Step-by-Step Guide

This section provides a comprehensive step-by step walkthrough to calculate the number of trips within each hexagonal grid during Weekday Morning Peak Hour with a subsequent plan to replicate the same process for Weekday Afternoon Peak Hour, Weekends/Holiday Morning Peak, and Weekends/Holiday Evening Peak in the subsequent section

#### Calculating Number of Trips in each Bus Stop

The code chunk below will be used to calculate the passenger trips in each origin bus stop.

```{r}
odbus_weekday_6_9_data <- odbus_weekday_6_9 %>%
  group_by(ORIGIN_PT_CODE) %>%
  summarise(Total_Trips = sum(TRIPS))%>% 
  mutate(ORIGIN_PT_CODE = as.factor(ORIGIN_PT_CODE))
```

#### Performing Relational Join

The code chunk below will be used to join the busstop3414 SpatialPolygonsDataframe and odbus_weekday_6_9_data by BUS_STOP_N for busstop3414 and BUS_STOP_ID for original_destination_bus). This is performed by using *left_join()* of **dplyr** package.

```{r}
total_trips_per_busstop_wdmp <- left_join(busstop3414, odbus_weekday_6_9_data, by = c("BUS_STOP_N" = "ORIGIN_PT_CODE")) %>%
  filter(!is.na(Total_Trips))
```

#### Spatial Join with honeycomb grid

The code chunk below will be used to join the total_trips_per_busstop and honeycomb grid spatially and remove the grid without any busstop (remove rows with NA value on the BUS_STOP_N).

```{r}
total_trips_per_busstop_honeycomb_wdmp_test <- st_join(honeycomb_grid_sf,total_trips_per_busstop_wdmp)
```

```{r}
total_trips_per_busstop_honeycomb_wdmp <- st_join(honeycomb_grid_sf,total_trips_per_busstop_wdmp) %>%
  filter(!is.na(BUS_STOP_N))
```

#### Calculating Total Trips in a Hexagonal Grid

The code chunk below will be used to calculate the total trips in a hexagonal grid.

```{r}
total_trips_per_grid_wdmp <- total_trips_per_busstop_honeycomb_wdmp %>%
  group_by(grid_id) %>%
  summarise(total_trips = sum(Total_Trips))
```

### Replicating Steps for Other Peak Hours

#### Weekday Afternoon Peak

```{r}
odbus_weekday_17_20_data <- odbus_weekday_17_20 %>%
  group_by(ORIGIN_PT_CODE) %>%
  summarise(Total_Trips = sum(TRIPS))%>% 
  mutate(ORIGIN_PT_CODE = as.factor(ORIGIN_PT_CODE))

total_trips_per_busstop_wdap <- left_join(busstop3414, odbus_weekday_17_20_data, by = c("BUS_STOP_N" = "ORIGIN_PT_CODE"))

total_trips_per_busstop_honeycomb_wdap <- st_join(honeycomb_grid_sf,total_trips_per_busstop_wdap) %>%
  filter(!is.na(BUS_STOP_N))

total_trips_per_grid_wdap <- total_trips_per_busstop_honeycomb_wdap %>%
  group_by(grid_id) %>%
  summarise(total_trips = sum(Total_Trips))
```

#### Weekends/Holiday Morning Peak

```{r}
odbus_weekend_11_14_data <- odbus_weekend_11_14 %>%
  group_by(ORIGIN_PT_CODE) %>%
  summarise(Total_Trips = sum(TRIPS))%>% 
  mutate(ORIGIN_PT_CODE = as.factor(ORIGIN_PT_CODE))


total_trips_per_busstop_wemp <- left_join(busstop3414, odbus_weekend_11_14_data, by = c("BUS_STOP_N" = "ORIGIN_PT_CODE"))

total_trips_per_busstop_honeycomb_wemp <- st_join(honeycomb_grid_sf,total_trips_per_busstop_wemp) %>%
  filter(!is.na(BUS_STOP_N))

total_trips_per_grid_wemp <- total_trips_per_busstop_honeycomb_wemp %>%
  group_by(grid_id) %>%
  summarise(total_trips = sum(Total_Trips))
```

#### Weekends/Holiday Evening Peak

```{r}
odbus_weekend_16_19_data <- odbus_weekend_16_19 %>%
  group_by(ORIGIN_PT_CODE) %>%
  summarise(Total_Trips = sum(TRIPS))%>% 
  mutate(ORIGIN_PT_CODE = as.factor(ORIGIN_PT_CODE))


total_trips_per_busstop_weep <- left_join(busstop3414, odbus_weekend_16_19_data, by = c("BUS_STOP_N" = "ORIGIN_PT_CODE"))

total_trips_per_busstop_honeycomb_weep <- st_join(honeycomb_grid_sf,total_trips_per_busstop_weep) %>%
  filter(!is.na(BUS_STOP_N))

total_trips_per_grid_weep <- total_trips_per_busstop_honeycomb_weep %>%
  group_by(grid_id) %>%
  summarise(total_trips = sum(Total_Trips))
```

## Geovisualisation and Analysis

### Weekday Afternoon Peak

```{r}
ggplot(data = total_trips_per_grid_wdmp,
       aes(x = total_trips)) +
  geom_histogram()
```

```{r}
ggplot(data = total_trips_per_grid_wdmp,
       aes(x = grid_id,
           y = total_trips)) +
  geom_point()
```

```{r}
ggplot(data=total_trips_per_grid_wdmp, aes(x = "", y = total_trips)) +
  geom_boxplot() +
  labs(title = "Boxplot", x = "Groups", y = "total_trips") +
  theme_minimal()
```

```{r}
tmap_mode("view")

tm_shape(total_trips_per_grid_wdmp) +
  tm_fill(
    col = "total_trips",
    palette = "Reds",
    style = "cont",
    title = "Number of Trips",
    id = "grid_id",
    showNA = FALSE,
    alpha = 0.6,
    popup.vars = c("total_trips"),
    popup.format = list(
      total_trips = list(format = "f", digits = 0))
  ) +
  tm_borders(col = "grey40", lwd = 0.7)

```

### Weekday Afternoon Peak

```{r}
tmap_mode("plot")

tm_shape(total_trips_per_grid_wdap) +
  tm_fill(
    col = "total_trips",
    palette = "Reds",
    style = "cont",
    title = "Number of Trips",
    id = "grid_id",
    showNA = FALSE,
    alpha = 0.6,
    popup.vars = c("total_trips"),
    popup.format = list(
      total_trips = list(format = "f", digits = 0))
  ) +
  tm_borders(col = "grey40", lwd = 0.7)

```

### Weekends/Holiday Morning Peak

```{r}
tmap_mode("plot")
tm_shape(total_trips_per_grid_wemp) +
  tm_fill(
    col = "total_trips",
    palette = "Reds",
    style = "cont",
    title = "Number of Trips",
    id = "grid_id",
    showNA = FALSE,
    alpha = 0.6,
    popup.vars = c("total_trips"),
    popup.format = list(
      total_trips = list(format = "f", digits = 0))
  ) +
  tm_borders(col = "grey40", lwd = 0.7)

```

### Weekends/Holiday Evening Peak

```{r}
tmap_mode("view")
tm_shape(total_trips_per_grid_weep) +
  tm_fill(
    col = "total_trips",
    palette = "Reds",
    style = "cont",
    title = "Number of Trips",
    id = "grid_id",
    showNA = FALSE,
    alpha = 0.6,
    popup.vars = c("total_trips"),
    popup.format = list(
      total_trips = list(format = "f", digits = 0))
  ) +
  tm_borders(col = "grey40", lwd = 0.7)

```

ANALYSIS : From the above, we can see there are more number of trip in the morning.....

Visualiation using ggplot...

choropleth...

## Distribution of passenger trips generate by origin at hexagon level

### Defining the Neighbourhood

#### Contiguity Weight Matrix (QUEEN)

```{r}
wm_q <- poly2nb(total_trips_per_grid_wdmp, queen=TRUE)
summary(wm_q)
```

There are 10 hexagonal grid with 0 neighbours and the most connected grid has 6 links.

#### Contiguity Weight Matrix (ROOK)

```{r}
wm_r <- poly2nb(total_trips_per_grid_wdmp, queen=FALSE)
summary(wm_r)
```

There are 10 hexagonal grid with 0 neighbours and the most connected grid has 6 links. So we should use distance-based neighbours.

### Visualising contiguity weights

```{r}
centroid <- st_centroid(total_trips_per_grid_wdmp$area_honeycomb_grid)
centroid
```

```{r}
longitude <- map_dbl(total_trips_per_grid_wdmp$area_honeycomb_grid, ~st_centroid(.x)[[1]])  
latitude <- map_dbl(total_trips_per_grid_wdmp$area_honeycomb_grid, ~st_centroid(.x)[[2]])  
coords <- cbind(longitude, latitude) 
tail(coords)
```

```{r}
summary(coords)
```

#### Plotting Queen and Rook Contiguity Based on Neighbours Map

```{r}
par(mfrow=c(1,2))
plot(total_trips_per_grid_wdmp$area_honeycomb_grid, border="lightgrey", main="Queen Contiguity")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
plot(total_trips_per_grid_wdmp$area_honeycomb_grid, border="lightgrey", main="Rook Contiguity")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

### **Computing distance based neighbours**

### **Determine the cut-off distance**

```{r}
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```

### **Computing fixed distance weight matrix**

```{r}
wm_d500 <- dnearneigh(coords, 0, 500, longlat = TRUE)
wm_d500
```

#### Adaptive Distance Weight Matrix

```{r}
knn6 <- knn2nb(knearneigh(coords, k=6))
knn6
```

#### Plotting distance based neighbours

```{r}
plot(total_trips_per_grid_wdmp$area_honeycomb_grid, border="lightgrey")
plot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

#### Inversed Distance 

## Task 2: **Local Indicators of Spatial Association (LISA) Analysis**

### **Deriving Continuity Spatial Weights: Queen's Method**

wm_q \<- hunan_GDPPC %\>% mutate(nb = st_contiguity(geometry), wt = st_weights(nb, style = "W"), .before=1)

Local Indicators of Spatial Association or LISA are statistics that evaluate the existence of clusters in the spatial arrangement of a given variable.

In this section, you will learn how to apply appropriate Local Indicators for Spatial Association (LISA), especially local Moran'I to detect cluster and/or outlier from passenger trips generate by origin at hexagon level.

The code chunks below are used to compute local Moran's I of Total Trips at the hexagonal grid level.

fips \<- order(total_trips_per_grid_wdmp\$grid_id) localMI \<- localmoran(hunan\$GDPPC, rswm_q) head(localMI)

Reproducible:

just change the read_csv and the file
