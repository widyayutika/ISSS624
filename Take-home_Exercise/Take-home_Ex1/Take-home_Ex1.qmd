---
title: "Take-home_Ex1: Public Bus Passengers in Singapore"
author: "Widya Tantiya Yutika"
date: "29 November 2023"
date-modified: "last-modified"
format: html
execute: 
  echo: true
  eval: true
  warning: false
editor: visual
---

## Overview

The increasing digitization of urban infrastructures, including buses, taxis, mass rapid transit, public utilities and roads, has generated vast datasets capturing movement patterns over space and time. This data, facilitated by technologies such as GPS and RFID, offers valuable insights into human mobility within cities. Smart cards and GPS devices on public buses, for instance, have enabled the collection of routes and ridership data, providing a rich source for understanding urban movement.

Despite the wealth of data collected, its utilization often remains limited to basic tracking and mapping using Geographic Information System (GIS) applications. This limitation is attributed to the inadequacy of conventional GIS functions in effectively analyzing and modeling spatial and spatio-temporal data.

The objectives of this study are centered around employing Exploratory Spatial Data Analysis (ESDA) techniques, specifically Local Indicators of Spatial Association (LISA) and Emerging Hot Spot Analysis (EHSA), to unveil the spatial and spatio-temporal mobility patterns of public bus passengers in Singapore.

## **The Study Area and Data**

### Aspatial Data

The aspatial data used in this take-home exercise is extracted from [LTA DataMall](https://datamall.lta.gov.sg/content/datamall/en.html) (*Passenger Volume by Origin Destination Bus Stops*) for the month of October 2023.

### Geospatial Data

The geospatial data used in this take-home exercise are as follows.

-   *Bus Stop Location* from [LTA DataMall](https://datamall.lta.gov.sg/content/datamall/en.html), which provides information about all the bus stops currently being serviced by buses, including the bus stop code (identifier) and location coordinates.

-   *hexagon*, a [hexagon](https://desktop.arcgis.com/en/arcmap/latest/tools/spatial-statistics-toolbox/h-whyhexagons.htm) layer of 250m perpendicular distance between the centre of the hexagon and its edges is used toeplace the relative coarse and irregular Master Plan 2019 Planning Sub-zone GIS data set of URA.

## **Setting the Analytical Tools**

Before I get started, I need to ensure that **sf**, **spdep**, **tmap**, **tidyverse,** and **knitr** packages of R are currently installed in my R.

-   *sf* : for importing and handling geospatial data in R,

-   *spdep* : for computing spatial weights, global and local spatial autocorrelation statistics, and

-   *tmap* : for preparing cartographic quality chropleth map

-   *tidyverse* : for wrangling attribute data in R ; [tidyverse](https://www.tidyverse.org/) has already included collection of packages such as readr, ggplot2, dplyr, tiblle, etc.

-   knitr: for facilitating dynamic report generation in R Markdown documents.

The code chunk below is used to ensure that the necessary R packages have been installed , if its iyet to be installed, it will then be installed and ready to be used in the R environment.

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse, knitr)
```

## **Getting the Data into R Environment**

### **Importing Shapefile into R Environment**

The code chunk below uses [*`st_read()`*](https://r-spatial.github.io/sf/reference/st_read.html) of **sf** package to import BusStop shapefile into R. The imported shapefile will be **simple features** Object of **sf**.

```{r}
busstop <- st_read(dsn = "data/geospatial", layer = "BusStop")
```

The code chunk below uses [*`st_geometry()`*](https://www.rdocumentation.org/packages/sf/versions/1.0-14/topics/st_geometry) of **sf** package to display basic information of feature class.

```{r}
st_geometry(busstop)
```

The code chunk below uses [*`glimpse()`*](https://www.rdocumentation.org/packages/dplyr/versions/1.0.10/topics/glimpse) of **dplyr** package to display the data type of each fields.

```{r}
glimpse(busstop)
```

Next, I will plot the geospatial data using the code chunk below.

```{r}
plot(busstop)
```

From the glimpse() check above, it is shown that the BUS_STOP_N is in character type. It needs to be converted to factor type to work with categorical variables so that I can use them to georeference with bus stop location data.

```{r}
busstop$BUS_STOP_N <- as.factor(busstop$BUS_STOP_N)
```

Next, I will confirm the data type for BUS_STOP_N has changed to data type of "factor" using glimpse().

```{r}
glimpse(busstop)
```

### **Importing Csv File into R Environment**

Next, I will import *origin_destination_bus_202310.csv* into R by using [*`st_read()`*](https://r-spatial.github.io/sf/reference/st_read.html) of **readr** package. The output is R dataframe class.

```{r}
odbus <- read_csv("data/aspatial/origin_destination_bus_202310.csv")
```

The code chunk below uses [*`glimpse()`*](https://www.rdocumentation.org/packages/dplyr/versions/1.0.10/topics/glimpse) of **dplyr** package to display the odbus tibble data tables.

```{r}
glimpse(odbus)
```

From the glimpse() check above, it is shown that the ORIGIN_PT_CODE and DESTINATION_PT_CODE are in character type. Both of them need to be converted to factor type to work with categorical variables so that I can use them to georeference with bus stop location data.

```{r}
odbus$ORIGIN_PT_CODE <- as.factor(odbus$ORIGIN_PT_CODE)
odbus$DESTINATION_PT_CODE <- as.factor(odbus$DESTINATION_PT_CODE) 
```

I will also change the data type of TIME_PER_HOUR and TOTAL_TRIPS from \<dbl\> to \<int\> because it both of these fields should be represented as whole numbers.

```{r}
odbus$TIME_PER_HOUR <- as.integer(odbus$TIME_PER_HOUR)
odbus$TOTAL_TRIPS <- as.integer(odbus$TOTAL_TRIPS) 
```

Next, I will confirm the data type for ORIGIN_PT_CODE and DESTINATION_PT_CODE have changed to factor using glimpse().

```{r}
glimpse(odbus)
```

## Data Wrangling

### Checking the Reference Coordinate System of Geospatial Data

Common issue in importing geospatial data into R is that the coordinate system of the source data was either missing (due to missing .proj for ESRI shapefile, etc.) or wrongly assigned.

The code chunk below uses [*`st_crs()`*](https://www.rdocumentation.org/packages/sf/versions/0.2-8/topics/st_crs) of **sf** package to retrieve the coordinate reference system of busstop.

```{r}
st_crs(busstop)
```

Both busstop is projected in svy21 as shown from the second line, but at the last line, it is mentioned that the EPSG is 9001. This is wrongly assigned because the correct EPSG code for svy21 is [3414](https://epsg.io/3414).

### Transforming the Projection

Next, I will transform busstop from geographic coordinate system to projected coordinated system as my analysis will measure distance or/and area.

The code chunk below uses [*`st_transform`*](https://r-spatial.github.io/sf/reference/st_transform.html) of **sp** package to convert coordinates to EPSG code of 3414.

```{r}
busstop3414 <- st_transform(busstop, 3414)
```

Next, I will check the coordinate system after transformation with the code chunk below.

```{r}
st_crs(busstop3414)
```

As noticed from the above, the Projected CRS is now SVY21 / Singapore TM and the last line has changed to EPSG 3414.

### Checking Duplicated Records

The code chunk below is used to check for duplicated records on odbus.

```{r}
duplicate <- odbus %>%
  group_by_all() %>%
  filter(n()>1) %>%
  ungroup()
```

The above code chunk shows that there is no duplicate record found.

### Remove Unnecessary Fields

First, I check the YEAR_MONTH and PT_TYPE unique values by using the *`table()`* to create a frequency table of each categorical representation.

```{r}
YEAR_MONTH_counts <- table(odbus$YEAR_MONTH)
print(YEAR_MONTH_counts)

DAY_TYPE_counts <- table(odbus$DAY_TYPE)
print(DAY_TYPE_counts)

PT_TYPE_counts <- table(odbus$PT_TYPE)
print(PT_TYPE_counts)
```

From the results above, I will exclude YEAR_MONTH and PT_TYPE as they only have single categorical representation using the code chunk below.

```{r}
odbus <- odbus[, !(names(odbus) %in% c("YEAR_MONTH", "PT_TYPE"))]
```

I will then use glimpse() to ensure the process is done correctly.

```{r}
glimpse(odbus)
```

## Creating honeycomb_grid

The code chunk below uses [*`st_make_grid`*](https://r-spatial.github.io/sf/reference/st_make_grid.html) of **sf** package to create a hexagonal or honeycomb grid with a 250m (perpendicular distance between the center of hexagon and its edges). According the the R documentation, the cellsize is the distance between opposite edges, which is 2 times the perpendicular distance between the center of hexagon and its edges. Thus, for the purpose of this exercise, I will use the cellsize of 500m and indicate the square=FALSE for hexagonal grid. After doing do, I will create a grid_id for each hexagonal grid.

```{r}
area_honeycomb_grid = st_make_grid(busstop3414, c(500, 500), what = "polygons", square = FALSE)    
# To sf and add grid ID  
honeycomb_grid_sf = st_sf(area_honeycomb_grid) %>%    
  # add grid ID      
  mutate(grid_id = 1:length(lengths(area_honeycomb_grid)))
```

## Extracting the study data

In this exercise, I will extract the commuting flows during peak hours as follows.

|                              | Bus tap on time |
|------------------------------|-----------------|
| Weekday morning peak         | 6am to 9am      |
| Weekday afternoon peak       | 5pm to 8pm      |
| Weekend/holiday morning peak | 11am to 2pm     |
| Weekend/holiday evening peak | 4pm to 7pm      |

### Weekday Morning Peak

The code chunk below will be used to extract the weekday morning peak (Weekday: 6-9am) and calculate the passenger trips in each origin bus stop by using the *`group_by()`* from **dplyr** package and aggregate the values using *`summarise()`* and sum up the "Total_Trips". The *`mutate()`* in the code below is to ensure that after the group_by, the ORIGIN_PT_CODE remains in the factor data type.

```{r}
odbus_weekday_6_9 <- odbus %>%
  filter(DAY_TYPE == "WEEKDAY") %>%
  filter(TIME_PER_HOUR >= 6 &
           TIME_PER_HOUR <= 9) %>%
  group_by(ORIGIN_PT_CODE) %>%
  summarise(TRIPS = sum(TOTAL_TRIPS))%>%
  mutate(ORIGIN_PT_CODE = as.factor(ORIGIN_PT_CODE))
```

I will repeat the processes above for the other peak hours as shown below.

### Weekday Afternoon Peak

The code chunk below will be used to extract the weekday afternoon peak (Weekday: 5-8pm) and calculate the passenger trips in each origin bus stop.

```{r}
odbus_weekday_17_20 <- odbus %>%   
  filter(DAY_TYPE == "WEEKDAY") %>%   
  filter(TIME_PER_HOUR >= 17 &            
           TIME_PER_HOUR <= 20) %>%   
  group_by(ORIGIN_PT_CODE) %>%   
  summarise(TRIPS = sum(TOTAL_TRIPS)) %>%
  mutate(ORIGIN_PT_CODE = as.factor(ORIGIN_PT_CODE))
```

### Weekends/Holiday Morning Peak

The code chunk below will be used to extract the weekend/holiday morning peak (Weekend/holiday: 11am-2pm) and calculate the passenger trips in each origin bus stop.

```{r}
odbus_weekend_11_14 <- odbus %>% 
  filter(DAY_TYPE == "WEEKENDS/HOLIDAY") %>%   
  filter(TIME_PER_HOUR >= 11 &            
           TIME_PER_HOUR <= 14) %>%   
  group_by(ORIGIN_PT_CODE) %>%   
  summarise(TRIPS = sum(TOTAL_TRIPS)) %>%
  mutate(ORIGIN_PT_CODE = as.factor(ORIGIN_PT_CODE))
```

### Weekends/Holiday Evening Peak

The code chunk below will be used to extract the weekend/holiday evening peak (Weekend/holiday: 4-7pm) and calculate the total trips in each origin and destination pair.

```{r}
odbus_weekend_16_19 <- odbus %>%   
  filter(DAY_TYPE == "WEEKENDS/HOLIDAY") %>%   
  filter(TIME_PER_HOUR >= 16 &            
           TIME_PER_HOUR <= 19) %>%   
  group_by(ORIGIN_PT_CODE) %>%   
  summarise(TRIPS = sum(TOTAL_TRIPS)) %>%
  mutate(ORIGIN_PT_CODE = as.factor(ORIGIN_PT_CODE))
```

## Further Data Wrangling for Weekday Morning Peak Hour: A Step-by-Step Guide

This section provides a comprehensive step-by step walkthrough to calculate the number of trips within each hexagonal grid during Weekday Morning Peak Hour with a subsequent plan to replicate the same process for Weekday Afternoon Peak Hour, Weekends/Holiday Morning Peak, and Weekends/Holiday Evening Peak in the subsequent section

### Performing Relational Join

The code chunk below will be used to join the busstop3414 SpatialPolygonsDataframe and odbus_weekday_6_9_data by BUS_STOP_N for busstop3414 and BUS_STOP_ID for original_destination_bus. This is performed by using `left_join()` of **dplyr** package. In this take-home exercise, I will focus on passenger trips generated by origin bus stop, I will remove the rows with bus stops solely serve as destinations which are indicated by NA values on the corresponding "Total_Trips" using the *`filter()`* from **dplyr** package.

```{r}
total_trips_per_busstop_wdmp <- left_join(busstop3414, odbus_weekday_6_9, by = c("BUS_STOP_N" = "ORIGIN_PT_CODE")) %>%
  filter(!is.na(TRIPS))
```

### Spatial Join with Hexagonal Honeycomb Grid and Calculating Total Trips in a Hexagonal Grid

The code chunk below will be used to join the total_trips_per_busstop and honeycomb grid spatially using *`st_join()`* from **sf** package and remove the hexagon grid without any bus stop which is indicated by NA value on the "BUS_STOP_N". Next, I will calculate the total trips in a hexagonal grid using the *`group_by()`* from **dplyr** package.

```{r}
total_trips_per_grid_wdmp <- st_join(honeycomb_grid_sf,total_trips_per_busstop_wdmp) %>%
  filter(!is.na(BUS_STOP_N))%>%
  group_by(grid_id) %>%
  summarise(total_trips = sum(TRIPS))
```

### Replicating the Steps for Other Peak Hours

#### Weekday Afternoon Peak

```{r}
total_trips_per_busstop_wdap <- left_join(busstop3414, odbus_weekday_17_20, by = c("BUS_STOP_N" = "ORIGIN_PT_CODE"))%>%
  filter(!is.na(TRIPS))

total_trips_per_grid_wdap <- st_join(honeycomb_grid_sf,total_trips_per_busstop_wdap) %>%
  filter(!is.na(BUS_STOP_N))%>%
  group_by(grid_id) %>%
  summarise(total_trips = sum(TRIPS))
```

#### Weekends/Holiday Morning Peak

```{r}

total_trips_per_busstop_wemp <- left_join(busstop3414, odbus_weekend_11_14, by = c("BUS_STOP_N" = "ORIGIN_PT_CODE"))%>%
  filter(!is.na(TRIPS))

total_trips_per_grid_wemp <- st_join(honeycomb_grid_sf,total_trips_per_busstop_wemp) %>%
  filter(!is.na(BUS_STOP_N))%>%
  group_by(grid_id) %>%
  summarise(total_trips = sum(TRIPS))
```

#### Weekends/Holiday Evening Peak

```{r}
total_trips_per_busstop_weep <- left_join(busstop3414, odbus_weekend_16_19, by = c("BUS_STOP_N" = "ORIGIN_PT_CODE"))%>%
  filter(!is.na(TRIPS))

total_trips_per_grid_weep <- st_join(honeycomb_grid_sf,total_trips_per_busstop_weep) %>%
  filter(!is.na(BUS_STOP_N))%>%
  group_by(grid_id) %>%
  summarise(total_trips = sum(TRIPS))
```

## Geovisualisation and Analysis

After the data preparation, I will first plot the distribution of passenger trips using *`ggplot()`* of **tidyverse** package. To consolidate these distributions into a single plot, it is necessary to introduce grouping variable to each dataframe. Within this unified plot, key summary statistics including Q1, median, Q3, and mean highligthed by a red circle will be presented. This approach aims to provide a comprehensive comparison of passenger trip characteristics across various peak hour groups.

```{r}
# Add a grouping variable to each dataframe
total_trips_per_grid_wdmp$Peak_Hour_Group <- "wdmp"
total_trips_per_grid_wdap$Peak_Hour_Group <- "wdap"
total_trips_per_grid_wemp$Peak_Hour_Group <- "wemp"
total_trips_per_grid_weep$Peak_Hour_Group <- "weep"

# Combine dataframes into a single dataframe
combined_peak_hour <- rbind(total_trips_per_grid_wdmp, total_trips_per_grid_wdap, total_trips_per_grid_wemp, total_trips_per_grid_weep) %>%
  filter(!is.na(total_trips))

# Create a box plot using ggplot
ggplot(combined_peak_hour, aes(x = Peak_Hour_Group, y = total_trips)) +
  geom_boxplot() +
  stat_summary(fun = "mean", geom = "point", shape = 18, size = 3, color = "red")+
  stat_boxplot(geom = 'errorbar', width = 0.5, color = 'blue', size = 1)+
  stat_summary(
    geom = 'text',
    fun.min = function(x) quantile(x, 0.25),
    fun = median,
    fun.max = function(x) quantile(x, 0.75),
    aes(label = sprintf("Q3: %.2f\nMedian: %.2f\nQ1: %.2f", ..ymax.., ..y.., ..ymin..)),
    vjust = -5,
    hjust= -0.08,
    position = position_dodge(width = 0.75),
    size = 3
  ) +
  stat_summary(geom = 'text', fun = mean, aes(label = sprintf("Mean: %.2f", ..y..)), vjust = -3, hjust=-0.08 ,  position = position_dodge(width = 0.9), color = 'red', size =3)+
  
  labs(title = "Boxplot for Total Trips in each Peak Hour Group", x="Peak Hour Group",y = "Passenger Trips") +
  theme_minimal()

```

The box plot analysis above reveal the patterns in Singapore's bus passenger trips. Notably, the mean passenger trips during weekdays significantly surpass those on weekends and holidays, suggesting higher demand for bus services during typical workdays. This aligns with a common observation that commuting is more crowded on workdays, reflecting the daily hustle and bustle of the workforce.

Furthermore, the observation that the mean of all peak hour groups exceeds their respective medians indicates a right-skewed distribution. This skewness implies that on average, there are more instances of relatively small number of passenger trips during peak hour with occasional instances of significantly higher demand. This distribution pattern underscores the challenges faced by commuters during peak hours, where a substantial portion of bus rides may experience higher congestion.

Some hexagonal grid has a total of more than 400,000 passenger trips highlighting that specific areas with exceptionally high demand during the weekdays. These areas are likely represent key commuting regions with concentrated commercial and residential activities and are possibly areas that are not easily accessible by MRT. To gain clearer insights on the concentrations of high passenger trips I will leverage **tmap** package.

### Weekday Morning Peak

```{r}
tmap_mode("view")

tm_shape(total_trips_per_grid_wdmp) +
  tm_fill(
    col = "total_trips",
    palette = c("#C5FFF8", "#FF4B91"),
    style = "cont",
    title = "Number of Trips",
    id = "grid_id",
    showNA = FALSE,
    alpha = 0.6,
    popup.vars = c("grid_id","total_trips"),
    popup.format = list(
      grid_id = list(format = "f", digits = 0),
      total_trips = list(format = "f", digits = 0))
  ) +
  tm_borders(col = "grey40", lwd = 0.7)
tmap_mode("plot")
```

It has been observed that certain bus stops are located outside the boundaries of Singapore, particularly in Johor.The influx of weekday morning peak passenger trips from Johor are qhigh surpassing 100,000 for October 2023. This significant amount shows the cross border commuting activity between Johor and Singapore suggesting a preference among some individuals to reside in Johor may be due to cost consideration while working in Singapore.

The Central Business District (CBD) area displays a comparatively lower passenger trips generated by origin bus stop. This is attributed to the absence of major bus interchanges within the CBD, suggesting that commuters in this central business hub may rely on alternative modes of transportation, such as the Mass Rapid Transit (MRT) system. In addition, it is worth noting that lower passenger trips may also be influences by the fact that bus routes typically do not commence within CBD area, even though the bus routes pass through CBD.

Areas that are exhibiting a high concentration during weekday morning peak are associated with prominent bus interchanges such as Woodlands and Boon Lay with more than 300,000 passenger trips within a single month on weekdays. Additionally, other bus interchanges including Bishan, Ang Mo Kio, Toa Payoh, Clementi, Punggol, Tampines, and Bedok also shows high passenger trips.

### Weekday Afternoon Peak

```{r}
tmap_mode("view")

tm_shape(total_trips_per_grid_wdap) +
  tm_fill(
    col = "total_trips",
    palette = c("#C5FFF8", "#FF4B91"),
    style = "cont",
    title = "Number of Trips",
    id = "grid_id",
    showNA = FALSE,
    alpha = 0.6,
    popup.vars = c("grid_id","total_trips"),
    popup.format = list(
      grid_id = list(format = "f", digits = 0),
      total_trips = list(format = "f", digits = 0))
  ) +
  tm_borders(col = "grey40", lwd = 0.7)
tmap_mode("plot")
```

During the weekday afternoon peak, Woodlands and Boon Lay continue to exhibit an impressive volume of passenger trips exceeding 400,000 as compared to the patterns observed during morning peak. In addition, there are additional areas such as Ang Mo Kio, Tampines, and Bedok which emerge as significant contributors to the passenger trips during the later peak period.

Typically the passengers volume during weekday afternoon are higher than weekday morning with Boon Lay with the highest contributor of more than 500,000 passenger trips. Boon Lay serves as a transportation hub for workers, residents and students from NTU. Moreover, the areas near Boon Lay are currently not accessible through MRT as the development of MRT is still in progress.

### Weekends/Holiday Morning Peak

```{r}
tmap_mode("view")
tm_shape(total_trips_per_grid_wemp) +
  tm_fill(
    col = "total_trips",
    palette = c("#C5FFF8", "#FF4B91"),
    style = "cont",
    title = "Number of Trips",
    id = "grid_id",
    showNA = FALSE,
    alpha = 0.6,
    popup.vars = c("grid_id","total_trips"),
    popup.format = list(
      grid_id = list(format = "f", digits = 0),
      total_trips = list(format = "f", digits = 0))
  ) +
  tm_borders(col = "grey40", lwd = 0.7)
tmap_mode("plot")
```

The peak hour for weekends/holiday morning are slightly late as compared to weekday morning.

### Weekends/Holiday Evening Peak

```{r}
tmap_mode("view")
tm_shape(total_trips_per_grid_weep) +
  tm_fill(
    col = "total_trips",
    palette = c("#C5FFF8", "#FF4B91"),
    style = "cont",
    title = "Number of Trips",
    id = "grid_id",
    showNA = FALSE,
    alpha = 0.6,
    popup.vars = c("grid_id","total_trips"),
    popup.format = list(
      grid_id = list(format = "f", digits = 0),
      total_trips = list(format = "f", digits = 0))
  ) +
  tm_borders(col = "grey40", lwd = 0.7)

```

## Distribution of passenger trips generate by origin at hexagon level

### Defining the Neighbourhood

#### Contiguity Weight Matrix (QUEEN)

```{r}
wm_q <- poly2nb(total_trips_per_grid_wdmp, queen=TRUE)
summary(wm_q)
```

There are 10 hexagonal grid with 0 neighbours and the most connected grid has 6 links.

#### Contiguity Weight Matrix (ROOK)

```{r}
wm_r <- poly2nb(total_trips_per_grid_wdmp, queen=FALSE)
summary(wm_r)
```

There are 10 hexagonal grid with 0 neighbours and the most connected grid has 6 links. So we should use distance-based neighbours.

### Visualising contiguity weights

```{r}
centroid <- st_centroid(total_trips_per_grid_wdmp$area_honeycomb_grid)
centroid
```

```{r}
longitude <- map_dbl(total_trips_per_grid_wdmp$area_honeycomb_grid, ~st_centroid(.x)[[1]])  
latitude <- map_dbl(total_trips_per_grid_wdmp$area_honeycomb_grid, ~st_centroid(.x)[[2]])  
coords <- cbind(longitude, latitude) 
tail(coords)
```

```{r}
summary(coords)
```

#### Plotting Queen and Rook Contiguity Based on Neighbours Map

```{r}
par(mfrow=c(1,2))
plot(total_trips_per_grid_wdmp$area_honeycomb_grid, border="lightgrey", main="Queen Contiguity")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
plot(total_trips_per_grid_wdmp$area_honeycomb_grid, border="lightgrey", main="Rook Contiguity")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

### **Computing distance based neighbours**

### **Determine the cut-off distance**

```{r}
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```

### **Computing fixed distance weight matrix**

```{r}
wm_d500 <- dnearneigh(coords, 0, 500, longlat = TRUE)
wm_d500
```

#### Adaptive Distance Weight Matrix

```{r}
knn6 <- knn2nb(knearneigh(coords, k=6))
knn6
```

#### Plotting distance based neighbours

```{r}
plot(total_trips_per_grid_wdmp$area_honeycomb_grid, border="lightgrey")
plot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

#### Inversed Distance

## Task 2: **Local Indicators of Spatial Association (LISA) Analysis**

### **Deriving Continuity Spatial Weights: Queen's Method**

wm_q \<- hunan_GDPPC %\>% mutate(nb = st_contiguity(geometry), wt = st_weights(nb, style = "W"), .before=1)

Local Indicators of Spatial Association or LISA are statistics that evaluate the existence of clusters in the spatial arrangement of a given variable.

In this section, you will learn how to apply appropriate Local Indicators for Spatial Association (LISA), especially local Moran'I to detect cluster and/or outlier from passenger trips generate by origin at hexagon level.

The code chunks below are used to compute local Moran's I of Total Trips at the hexagonal grid level.

fips \<- order(total_trips_per_grid_wdmp\$grid_id) localMI \<- localmoran(hunan\$GDPPC, rswm_q) head(localMI)

Reproducible:

just change the read_csv and the file
